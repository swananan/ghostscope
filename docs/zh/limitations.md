# GhostScope 的限制

## 硬性限制

### 1. 权限需求
eBPF 底层机制要求提升的权限以访问内核追踪基础设施，需要 root 权限或 CAP_BPF/CAP_SYS_ADMIN 能力。

### 2. 不要与 GDB 同时使用
uprobe 和 GDB 都会修改目标进程的指令（插入断点），同时使用可能导致冲突和不可预测的行为。

### 3. eBPF bpf_probe_read_user 限制
eBPF 的 helper 函数不支持处理缺页错误，在读取目标进程的虚拟地址数据时可能会失败。这是 eBPF 的设计限制。

**参考**：https://lists.iovisor.org/g/iovisor-dev/topic/accessing_user_memory_and/21386221

### 4. 只读访问，不可修改程序行为
虽然 eBPF 在技术上支持一定程度上修改进程行为，但是 GhostScope 设计为只读工具，无法修改程序状态、变量值或控制流。这确保了在生产环境中的安全性。

## 软性限制

### 1. 语言支持
目前主要支持编译型语言（C、C++、Rust）及其生成的 DWARF 调试信息。对于这些语言的高级特性支持有限，例如 Rust 的异步函数、C++ 的模板等，需要投入大量精力逐步完善。

对于解释型语言（Lua、Python、Ruby 等），目前只能追踪解释器本身（因为解释器通常用编译型语言实现）。追踪脚本代码在技术上可行，但需要大量开发时间，JIT 语言支持计划就更远了。

### 2. 平台支持
目前仅支持 x86_64 (AMD64) 架构。其他平台（如 ARM64）技术上可行，但需要投入时间适配和测试。

### 3. 性能影响
基于 uprobe 的实现，每次探针触发会产生一次上下文切换开销以及 eBPF 程序执行时间。如果探针设置在热点路径上，可能对被监测进程造成明显的性能影响，使用时需要谨慎。

### 4. 事件丢失（背压）
使用 ring buffer 在 eBPF 程序和用户态之间传递事件。如果事件产生速率过快，超过用户态消费能力，内核会丢弃事件，导致追踪数据缺失。目前 GhostScope 的错误提示还不够完善（后面会学习 bpftrace 是怎么处理这种的），建议避免在高频路径上设置过多探针。

### 5. DWARF 支持范围
主要测试和验证了 DWARF 5 格式。理论上支持 DWARF 2-5，但其他版本可能存在兼容性问题。部分 DWARF 表达式指令暂不支持转换为 eBPF（纯实现还没有支持的原因），遇到时会给出明确的错误提示。

### 6. 高度优化代码的支持
编译器优化（-O2、-O3）会导致变量被优化掉或生成复杂的 DWARF 表达式。GhostScope 会尽力解析，包括内联函数的支持，但部分变量可能无法访问（显示为 OptimizedOut），这是因为编译器优化掉了。

### 7. 动态加载库（dlopen）
GhostScope 启动时会扫描进程的 `/proc/PID/maps` 获取已加载的动态库信息。只要在 `dlopen` 之后启动 GhostScope，就可以正常追踪。后续计划支持动态监控进程的 `dlopen` 行为，提供更好的体验。


