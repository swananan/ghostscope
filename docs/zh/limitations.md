# GhostScope 的限制

## 硬性限制

### 1. 权限需求
eBPF 底层机制要求提升的权限以访问内核追踪基础设施，需要 root 权限或 CAP_BPF/CAP_SYS_ADMIN 能力。

### 2. 不要与 GDB 同时使用
uprobe 和 GDB 都会修改目标进程的指令（插入断点），同时使用可能导致冲突和不可预测的行为。

### 3. eBPF bpf_probe_read_user 限制
eBPF 的 helper 函数不支持处理缺页错误，在读取目标进程的虚拟地址数据时可能会失败。这是 eBPF 的设计限制。

**参考**：https://lists.iovisor.org/g/iovisor-dev/topic/accessing_user_memory_and/21386221

### 4. 只读访问，不可修改程序行为
虽然 eBPF 在技术上支持一定程度上修改进程行为，但是 GhostScope 设计为只读工具，无法修改程序状态、变量值或控制流。这确保了在生产环境中的安全性。

### 5. 平台支持
目前仅支持 **Linux** 操作系统，因为核心技术依赖 **eBPF** 和 **uprobe**。

## 软性限制

### 1. 语言支持
主要支持 **C 语言**，对 C 的支持最为完善。C++ 和 Rust 是有限支持 - 这些语言的高级特性支持有限，例如 Rust 的异步函数、C++ 的模板等，需要投入大量精力逐步完善。

对于解释型语言（Lua、Python、Ruby 等），目前只能追踪解释器本身（因为解释器通常用编译型语言实现）。追踪脚本代码在技术上可行，但需要大量开发时间，JIT 语言支持计划就更远了。

### 2. 架构支持
目前仅支持 **x86_64 (AMD64)** 架构。其他平台（如 ARM64）技术上可行，但需要投入时间适配和测试。

### 3. 性能影响
基于 uprobe 的实现，每次探针触发会产生一次上下文切换开销以及 eBPF 程序执行时间。如果探针设置在热点路径上，可能对被监测进程造成明显的性能影响，使用时需要谨慎。

### 4. 事件丢失（背压）
使用 ring buffer 在 eBPF 程序和用户态之间传递事件。如果事件产生速率过快，超过用户态消费能力，内核会丢弃事件，导致追踪数据缺失。目前 GhostScope 的错误提示还不够完善（后面会学习 bpftrace 是怎么处理这种的），建议避免在高频路径上设置过多探针。

### 5. DWARF 支持范围
主要测试和验证了 DWARF 5 格式。理论上支持 DWARF 2-5，但其他版本可能存在兼容性问题。部分 DWARF 表达式指令暂不支持转换为 eBPF（纯实现还没有支持的原因），遇到时会给出明确的错误提示。

### 6. 高度优化代码的支持
编译器优化（-O2、-O3）会导致变量被优化掉或生成复杂的 DWARF 表达式。GhostScope 会尽力解析，包括内联函数的支持，但部分变量可能无法访问（显示为 OptimizedOut），这是因为编译器优化掉了。

### 7. 动态加载库（dlopen）
GhostScope 启动时会扫描进程的 `/proc/PID/maps` 获取已加载的动态库信息。只要在 `dlopen` 之后启动 GhostScope，就可以正常追踪。后续计划支持动态监控进程的 `dlopen` 行为，提供更好的体验。

### 8. -t 模式下不支持全局变量

使用 `-t`（基于可执行文件路径启动）时，当前无法解析全局变量。原因是全局变量在运行时需要结合进程的 `/proc/<pid>/maps` 计算 ASLR 偏移（每个模块的 `.text/.rodata/.data/.bss` 偏移），而 `-t` 模式没有已知的 PID 上下文，无法安全地填充 eBPF 侧的偏移映射，因此会禁用全局变量能力。

提示：`-p <pid>` 模式下会自动计算并下发模块偏移，全局变量可用。

