# Uprobe 内部机制

了解 GhostScope 如何使用 Linux uprobe 和 eBPF 进行动态追踪。

## 什么是 Uprobe？

Uprobe（用户空间探针）是 Linux 内核的一个功能，允许您在运行时动态地对用户空间应用程序进行插桩，无需修改二进制文件或重新编译。它是 Linux 内核提供的动态追踪基础设施的核心组件之一。

## Uprobe 工作原理

### 基本执行流程

```
用户进程执行
     ↓
  触发断点指令 (int3)
     ↓
  CPU 陷入内核态
     ↓
  内核 uprobe 处理器识别
     ↓
  调用注册的 eBPF 程序
     ↓
  eBPF 程序执行并收集数据
     ↓
  单步执行原始指令
     ↓
  恢复用户态执行
```

### 1. 探针插入

当您在特定地址设置 uprobe 时：
1. 内核将该地址的原始指令替换为断点指令（x86_64 上是 `int3`，占 1 字节）
2. 原始指令被保存在内核的 uprobe 管理结构中
3. 当程序执行流到达该地址时，会触发断点异常

### 2. 陷阱处理

当断点被触发时的完整流程：
1. **CPU 陷入**：断点指令导致 CPU 从用户态切换到内核态
2. **识别 uprobe**：内核陷阱处理程序识别这是一个 uprobe 断点
3. **执行回调**：调用注册在该 uprobe 上的所有回调（包括 eBPF 程序）
4. **eBPF 执行**：eBPF 程序运行，可以读取寄存器、栈、内存等
5. **单步执行**：使用单步调试机制执行被替换的原始指令
6. **恢复执行**：返回用户态，继续正常执行

### 3. 性能特征

- **开销**：每次探针命中约 1-3 微秒（包括上下文切换和 eBPF 执行）
- **上下文切换**：一次完整的用户态 → 内核态 → 用户态转换
- **内存占用**：每个探针约占用几百字节的内核内存
- **可扩展性**：内核能高效处理数千个探针同时活动

## 📢 深入理解 Uprobe 的关键问题

### 1. Uprobe 需要哪些信息？

Uprobe 本质上只需要两个核心信息：
- **文件路径**：可执行文件或动态库的路径（内核通过它找到 inode）
- **文件偏移**：被探测指令在文件中的偏移量（不是虚拟内存地址！）

工作机制：
- Uprobe 通过修改指令的方式实现探测
- eBPF 程序只是注册在 uprobe 框架上的回调之一
- 内核负责断点管理，eBPF 只负责数据收集

### 2. Uprobe 附加时会影响哪些进程？

**核心原理**：Uprobe 基于文件系统的 **inode** 工作，而非进程 PID。

#### Inode 到进程的影响路径

```
                   uprobe_register(inode, offset)
                            ↓
                   遍历 inode 的地址空间
                            ↓
        ┌───────────────────┴───────────────────┐
        │    inode->i_mapping->i_mmap           │
        │  (红黑树：所有映射此文件的 VMA)        │
        └───────────────────┬───────────────────┘
                            ↓
        ┌───────────────────────────────────────┐
        │  遍历每个 VMA (vm_area_struct)        │
        └───────────────────┬───────────────────┘
                            ↓
                ┌───────────┴───────────┐
                │                       │
         VMA 1: Process A        VMA 2: Process B
         (mm->mmap)              (mm->mmap)
                │                       │
                ↓                       ↓
         在 vaddr 处插入断点      在 vaddr 处插入断点
         (通过 install_breakpoint)

关键数据结构：
• inode: 文件的唯一标识
• i_mapping->i_mmap: 该文件的所有内存映射（红黑树）
• vm_area_struct (VMA): 进程地址空间中的一段映射区域
• mm_struct: 进程的内存描述符
```

#### 影响范围

**所有映射该 inode 的进程都会被影响**，这包括：
1. 主可执行文件：所有运行该程序的进程实例
2. 动态库：所有加载了该库的进程（可能跨越不同程序）
3. 共享库：系统中可能有数十个进程共享同一个 libc.so

#### ⚠️ 重要边界情况

**文件更新导致的 Inode 不一致**：

```
场景：运行中的程序文件被更新

  旧进程              文件系统           新进程
    │                    │                 │
    ├─ 映射 inode A      │                 │
    │  /usr/bin/app      │                 │
    │  (启动时映射)      │                 │
    │                    │                 │
                  程序被重新编译/替换
                         ↓
    │                    │                 │
    │              inode B 创建            │
    │              /usr/bin/app            │
    │              (新版本)                │
    │                    │                 │
    │                    │              新进程启动
    │                    │                 │
    │                    │                 ├─ 映射 inode B
    │                    │                 │
    │                    │                 │
  uprobe 附加到 inode B                    │
         ↓                                 ↓
   ❌ 旧进程不受影响          ✅ 新进程被探测
   (仍映射 inode A)          (映射 inode B)
```

**关键结论**：
- 旧进程使用的是旧文件的 inode（通过 `mmap` 在启动时保留）
- 文件更新会创建新的 inode（或修改已有 inode，取决于编辑器行为）
- Uprobe 只影响与注册时的 inode 匹配的进程
- 如果要探测旧进程，需要：
  - 使用 `-p PID` 模式（GhostScope 会找到该进程映射的实际 inode）
  - 或者保留旧版本文件并对其设置 uprobe

**实际验证方法**：
```bash
# 查看进程映射的文件 inode
cat /proc/$PID/maps | grep "r-xp"
ls -i /usr/bin/app  # 查看当前文件 inode

# 如果 inode 不匹配，uprobe 不会生效
```

### 3. Uprobe 可以附加到哪些位置？

传统工具（如 bpftrace）通常只支持：
- 函数入口点（基于符号表）
- 函数返回点（uretprobe）
- 手动指定的文件偏移

**GhostScope 的优势**：借助 DWARF 调试信息，可以附加到：

| 位置类型 | 示例 | 实现方式 |
|---------|------|---------|
| **函数入口** | `main` | 符号表查找 → 文件偏移 |
| **函数返回** | `main` (uretprobe) | 内核 uretprobe 机制 |
| **源代码行** | `sample.c:42` | DWARF `.debug_line` 映射 |
| **内联函数** | `inline_func` | DWARF `.debug_info` 内联实例 |
| **任意地址** | `file_path:0x401234` | 直接使用偏移 |

**关键转换流程**：
```
源代码行号 (sample.c:42)
         ↓
  DWARF .debug_line 表
         ↓
  虚拟内存地址 (0x401234)
         ↓
  减去加载基址 (PIE/ASLR 处理)
         ↓
  文件偏移 (0x1234)
         ↓
uprobe_register(inode, 0x1234)
```

注意
- 脚本/CLI 的地址目标使用的是“模块相对虚拟地址（DWARF PC）”。也就是说，在脚本中 `trace libc.so.6:0xADDR { ... }` 或 `trace 0xADDR { ... }` 里的 `0xADDR` 是该模块的 DWARF PC。GhostScope 会在内部将该虚拟地址换算为 ELF 文件偏移（无论 PIE 或非 PIE），再进行 uprobe 附着。请勿与“原始文件偏移”混淆。

### 4. ASLR 对 Uprobe 的影响

#### 背景知识

现代 Linux 系统默认启用 **ASLR (Address Space Layout Randomization)**，每次进程启动时：
- 可执行文件的加载基址随机化
- 动态库的加载基址随机化
- 栈、堆等区域的地址也随机化

**核心要点**：Uprobe 使用**文件偏移**（file offset）而非虚拟地址（virtual address），因此不受 ASLR 影响。明确这一点之后，这一小节下面的内容其实就不是很重要了。

#### PIE vs 非 PIE 的地址转换

两种可执行文件类型在地址转换上有本质区别：

##### PIE (Position Independent Executable)

**特征**：
- 编译时使用 `-fPIE -pie` 标志
- 可以加载到内存的任意位置
- DWARF 中记录的是**相对地址**（相对于加载基址）

**地址转换**：
```
DWARF 地址 (相对地址)
         ↓
     直接就是文件偏移
         ↓
  uprobe_register(inode, dwarf_addr)
```

**示例**：
```c
// 编译：gcc -g -fPIE -pie main.c -o app_pie

// DWARF 信息：
// main 函数地址: 0x1234

// 实际转换：
file_offset = 0x1234  // DWARF 地址就是文件偏移
```

**运行时行为**：
```
进程 A 启动 → 加载到 0x55ab1234 (基址 0x55ab0000)
进程 B 启动 → 加载到 0x7f3e1234 (基址 0x7f3e0000)
                       └─────┬─────┘
                      都映射文件偏移 0x1234
                      Uprobe 在此设置断点
```

##### 非 PIE (传统可执行文件)

**特征**：
- 编译时不使用 PIE 标志（或使用 `-no-pie`）
- 加载到固定的虚拟地址（通常是 0x400000）
- DWARF 中记录的是**绝对虚拟地址**

**地址转换**：
```
DWARF 地址 (绝对虚拟地址)
         ↓
    减去 ELF 段的虚拟基址
         ↓
     得到文件偏移
         ↓
  uprobe_register(inode, file_offset)
```

**示例**：
```c
// 编译：gcc -g -no-pie main.c -o app_nopie

// ELF Program Header:
//   LOAD: VirtAddr=0x400000, FileOffset=0x0000, MemSize=0x2000

// DWARF 信息：
//   main 函数地址: 0x401234 (绝对地址)

// 实际转换：
file_offset = 0x401234 - 0x400000 = 0x1234
```

**关键公式**：
```
file_offset = dwarf_addr - segment_vaddr
```

其中 `segment_vaddr` 是 ELF `LOAD` 段的 `VirtAddr` 字段。

#### 为什么 Uprobe 不受 ASLR 影响？

```
       进程 A (PIE)               进程 B (非 PIE)
            │                          │
  ┌─────────▼─────────┐      ┌────────▼────────┐
  │ 加载基址: 随机    │      │ 加载基址: 固定   │
  │ 0x55ab0000       │      │ 0x400000        │
  └─────────┬─────────┘      └────────┬────────┘
            │                          │
            │  mmap(file, offset)      │
            │                          │
            └────────┬─────────────────┘
                     ↓
         ┌───────────────────────┐
         │  文件系统 Inode        │
         │  文件偏移 0x1234       │  ← Uprobe 在此设置
         └───────────────────────┘

关键：
• 虚拟地址 = 加载基址 + 文件偏移
• Uprobe 只关心文件偏移
• 不同进程的虚拟地址可能不同
• 但文件偏移永远相同
```

#### 特殊情况：访问全局变量

虽然 uprobe 不受 ASLR 影响，但如果需要读取**全局变量**或**绝对地址数据**，则必须考虑运行时地址，不过这个属于是 GhostScope 的实现细节了，我这边就不赘述了。

## GhostScope 的两种追踪模式

### 模式 1：特定 PID 模式（`-p`）

```bash
sudo ghostscope -p 12345
```

#### 工作原理

```
    GhostScope 启动
          ↓
    读取 /proc/12345/maps
          ↓
    获取进程的内存映射信息
          ↓
    ┌──────────────────────────────┐
    │ 主可执行文件: /usr/bin/app  │ → inode A
    │ 动态库 1: /lib/libc.so.6     │ → inode B
    │ 动态库 2: /lib/libssl.so     │ → inode C
    └──────────────────────────────┘
          ↓
    进行 dwarf 分析
          ↓
    根据目标文件和指令偏移去注册 uprobe
          ↓
    eBPF 程序包含 PID 过滤逻辑
          ↓
    if (bpf_get_current_pid_tgid() >> 32 != 12345) {
        return 0;  // 忽略其他进程
    }
```

#### 技术细节

1. **Mapping 解析**：
   - 解析 `/proc/PID/maps` 获取所有映射的可执行区域（`r-xp` 权限）
   - 每个映射区域对应一个文件 inode
   - 对这些 inode 设置 uprobe（会影响所有映射这些 inode 的进程）

2. **eBPF 过滤**：
   ```c
   // eBPF 程序开头的过滤逻辑
   u64 pid_tgid = bpf_get_current_pid_tgid();
   u32 pid = pid_tgid >> 32;

   if (pid != target_pid) {
       return 0;  // 快速返回，不收集数据
   }

   // 继续执行追踪逻辑...
   ```

3. **为什么不能只对特定进程设置 uprobe？**
   - Uprobe 是基于 **inode** 的，无法指定 PID
   - 必须在 eBPF 层面进行过滤
   - 其他进程触发断点，但 eBPF 程序会快速返回（开销很小）

#### 优势与限制

✅ **优势**：
- 输出专注于目标进程，无噪音
- 适合调试特定实例的问题
- eBPF 过滤非常高效（< 100ns）

❌ **限制**：
- 无法捕获进程启动阶段（GhostScope 附加时进程已在运行）
- 如果程序文件被替换，旧进程仍然可以被追踪（因为映射的是旧 inode）
- 动态加载的库（`dlopen`）目前不支持自动追踪

#### 使用场景

- 调试特定进程的异常行为
- 性能分析已运行的服务实例
- 需要减少追踪输出噪音的场景

---

### 模式 2：全二进制模式（`-t`）

```bash
sudo ghostscope -t /usr/bin/myapp
```

#### 工作原理

```
    GhostScope 启动
          ↓
    dwarf 解析以及获取目标文件地址
          ↓
    uprobe_register(inode, offset)
          ↓
    内核遍历该 inode 的所有映射
          ↓
    ┌─────────────────────────────────────┐
    │  进程 A (PID 100): /usr/bin/myapp  │ ✅ 被探测
    │  进程 B (PID 200): /usr/bin/myapp  │ ✅ 被探测
    │  进程 C (PID 300): /usr/bin/other  │ ❌ 不同 inode
    └─────────────────────────────────────┘
          ↓
    所有映射该 inode 的进程都触发 eBPF 程序
          ↓
    eBPF 程序**不做 PID 过滤**
          ↓
    所有事件都会发送到用户态
```

#### 优势与限制

✅ **优势**：
- 可以捕获进程从启动到退出的完整生命周期
- 自动追踪所有实例，无需知道 PID
- 适合追踪短生命周期进程（如 CGI 脚本）
- 可以追踪动态库在不同进程中的使用

❌ **限制**：
- 输出包含所有使用该二进制的进程（可能很嘈杂）
- 对于共享库（如 libc），可能影响系统中大量进程
- 需要手动过滤感兴趣的进程输出

#### 使用场景

- 调试程序启动阶段的问题
- 追踪服务的所有实例（如 nginx worker 进程）
- 监控共享库在整个系统中的行为
- 捕获多进程环境中的竞态条件
- 分析频繁启动的短期进程

---
