# 常见问题

## 什么是 GhostScope？

GhostScope 是一个基于 eBPF 的运行时追踪器，允许你在不修改源代码、不重新编译、不重启进程的情况下，实时观察和分析运行中的应用程序。可以把它理解为生产系统的"printf 调试"工具。

## GhostScope 与 GDB 有什么区别？

| 特性 | GhostScope | GDB |
|------|------------|-----|
| 类型 | 追踪器（类似高级 printf） | 交互式调试器 |
| 运行时开销 | 极小 | 高（停止执行） |
| 进程中断 | 从不 | 是（断点） |
| 生产环境使用 | 是，专为此设计 | 否 |
| 时序保持 | 是 | 否（断点改变时序） |
| 并发调试 | 优秀 | 困难 |
| 交互控制 | 否（但是提供 TUI 界面） | 是（单步、继续等） |

## bpftrace 与 GhostScope 有什么区别？

| 维度 | bpftrace | GhostScope |
|---|---|---|
| 定位 | 通用 eBPF 动态追踪器，偏事件统计/观测 | “DWARF 感知”的用户态观测，偏源码语义还原 |
| DWARF 使用 | 参数/结构体解析，不求值 location expr | 运行时求值 DWARF 表达式，读参/局部/全局 |
| 附着粒度与符号 | 入口/返回/偏移/绝对地址；无内建行表映射 | 行表驱动源码行/指令级附着与求值 |
| 可观测数据 | 参数只支持函数入口获取；不支持局部变量；全局只能用 `uaddr()` | 支持局部变量、参数和全局变量，并能按真实类型渲染值 |
| ASLR 影响 | 全局变量使用 `uaddr()` 时，在 ASLR/PIE 的场景下不可用  | 运行时按 DWARF 计算，天然适配 ASLR/PIE |
| 交互体验 | 脚本式输出与聚合，非交互 | TUI 友好界面，可以不中断观测 |

我其实是看到了 bpftrace 在最近新的版本里面去掉了对 DWARF 的大部分功能支持，我才开始启动这个项目的，哈哈。

## SystemTap 与 Ghostscope 有什么区别？
| 维度 | SystemTap eBPF 后端（stapbpf） | GhostScope |
|---|---|---|
| 定位与范围 | 系统级 eBPF 追踪后端（内核+用户态），功能较内核模块后端有所取舍 | “DWARF 感知”的用户态观测，面向生产 printf 调试与交互体验 |
| 源码行/语句级设点 | 支持（.statement 解析为地址后附着） | 支持（基于行表/地址/函数，行级附着是核心） |
| 变量访问（参/局/全） | 支持。DWARF 位置表达式→AST→降为 eBPF（probe_read/pt_regs 偏移）；受 eBPF 栈/验证器与字符串长度约束 | 支持。运行时用 gimli 求值 DWARF；按真实类型渲染值，天然适配 ASLR/PIE |
| DWARF 表达式处理 | loc2stap 解释 DW_OP → 内部表达，再由 bpf_unparser 降成 eBPF 指令序列 | 直接在用户态用 gimli 求值，结果通过 eBPF 程序采集、TUI 展示 |
| 栈回溯（CFI） | 不支持（eBPF 后端无用户态回溯能力） | 不支持（后续计划支持，通过 .eh_frame 展开） |
| 事件传输/格式化 | PERF_EVENT_ARRAY + perf_event_output；用户态解释器完成 printf；BPF_MAXSTRINGLEN≈64、格式串≈256 | 支持 RingBuf（≥5.8）或 PerfEventArray，容量/页数/事件大小可配；内置 {:x.N}/{:s.N}/{:p} 等多种 dump 数据的方式 |
| BTF/CO‑RE/链接 | 不用 BTF/CO‑RE；最小 libbpf（直接 bpf()），无 bpf_link/ringbuf | Aya 生态，优先 RingBuf；不以 BTF/CO‑RE 为核心 |
| eBPF 生成链 | 自研 IR/汇编器直接产 eBPF 字节码与 ELF（.bo），装载器做 R_BPF_MAP_FD 重定位 | Rust/Aya 装载，专注用户态 DWARF 变量读取与展示 |
| 交互与体验 | CLI + 用户态解释器输出；学习曲线较陡 | TUI 友好，实时/会话日志与脚本 DSL，贴近“生产 printf 调试” |

我其实一开始并不清楚 SystemTap 已经支持了 eBPF 后端，我一直还停留在当初的印象：即小心翼翼的编写 SystemTap 脚本，然后在测试机上反复测试，然后偷偷在线上一台小流量机器上对服务进行探测，抓到需要的信息就赶快停下来，生怕把机器弄宕机（当然，应该是我自己没有掌握好 SystemTap 工具的使用，才会有这样的情况）。如果我早点知道这个事情，我可能都不太会启动这个项目了😂，不过我至少可以安慰自己，GhostScope 其实是一个更易用的 TUI 工具，专注于用户态程序探测，有着自己独特的价值。

## GDB、SystemTap、bpftrace 以及 GhostScope 使用场景选择
- **使用 GhostScope 的场景**
    - 用户态程序的源码级定位，按 `函数/源码行/地址`读取`真实变量值`（含局部/全局变量以及参数）且不干扰服务运行
    - 追求生产可用的低开销与更好的交互（cgdb 风格的 TUI ）
    - 要快速上手、降低脚本复杂度与环境依赖
- **使用 GDB 的场景：**
    - 需要交互式检查复杂数据结构
    - 想在调试期间修改变量
    - 需要逐行单步执行代码
    - 调试 coredump 文件
    - 在开发环境中允许停止执行
- **使用 bpftrace 的场景**
    - 同一脚本混合多类事件源（内核+用户态）做系统级观测
    - **对用户态程序源码级别变量的追踪细节要求不高**
- **使用 SystemTap 场景**
    - 同一脚本混合多类事件源（内核+用户态）做系统级观测
    - 已有 SystemTap 脚本/生态（tapset）基础，便于迁移复用
    - 对聚合/统计有基本需求

## GhostScope 的限制有哪些？

请参阅 [使用限制](limitations.md) 文档，了解硬性限制和软性限制的完整列表。

## 未来规划是什么样的？

请参阅 [未来规划](roadmap.md) 文档，了解计划中的功能和未来开发方向。
