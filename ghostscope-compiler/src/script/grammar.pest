WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

program = _{ SOI ~ statement* ~ EOI }

statement = {
    trace_stmt |
    print_stmt |
    backtrace_stmt |
    if_stmt |
    assign_stmt |
    expr_stmt |
    var_decl_stmt
}

trace_stmt = { "trace" ~ trace_pattern ~ "{" ~ statement* ~ "}" }
trace_pattern = { 
    module_hex_address |
    hex_address |
    wildcard_pattern |
    source_line |
    function_name
}

hex_address = @{ "0x" ~ ASCII_HEX_DIGIT+ }
module_hex_address = { file_path ~ ":" ~ hex_address }
wildcard_pattern = @{ identifier ~ "*" }
source_line = { file_path ~ ":" ~ line_number }
function_name = { identifier }

file_path = @{ (ASCII_ALPHANUMERIC | "_" | "/" | "." | "-")+ }
line_number = @{ ASCII_DIGIT+ }

print_stmt = { "print" ~ print_content ~ ";" }
print_content = {
    format_expr |      // print "format {} {}", arg1, arg2 (must be first to match)
    string |           // print "hello world"
    expr               // print expression (covers variable, member, array, pointer, etc.)
}
format_expr = { string ~ "," ~ expr ~ ("," ~ expr)* }
backtrace_stmt = { ("backtrace" | "bt") ~ ";" }
expr_stmt = { expr ~ ";" }
var_decl_stmt = { "let" ~ identifier ~ "=" ~ expr ~ ";" }
assign_stmt = { identifier ~ "=" ~ expr ~ ";" }

// Conditional statements (Rust style)
if_stmt = { "if" ~ condition ~ "{" ~ statement* ~ "}" ~ else_clause? }
else_clause = { "else" ~ ( if_stmt | ("{" ~ statement* ~ "}") ) }

// Condition for if statements
condition = { expr }
compare_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

// Expression system with comparison support
expr = { logical_or }
or_op = { "||" }
and_op = { "&&" }
logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { equality ~ (and_op ~ equality)* }
eq_op = { "==" | "!=" }
rel_op = { "<=" | ">=" | "<" | ">" }
equality = { relational ~ (eq_op ~ relational)* }
relational = { additive ~ (rel_op ~ additive)* }
additive = { term ~ (add_op ~ term)* }
// Support unary minus by introducing a 'unary' level
term = { unary ~ (mul_op ~ unary)* }
// Note: use recursive definition so multiple '-' nest correctly and parser can detect '-' branch
neg_unary = { "-" ~ unary }
not_unary = { "!" ~ unary }
unary = { neg_unary | not_unary | factor }
factor = {
    // Builtin calls must be checked before identifier to avoid ambiguity
    memcmp_call |
    strncmp_call |
    starts_with_call |
    hex_call |
    bool |
    string |
    hex_int |
    oct_int |
    bin_int |
    float |
    int |
    special_var |
    array_access |      // prefer array[index].field over chain_access to avoid premature match
    chain_access |      // allow a.b.c and a.b.c[expr] (trailing index only)
    member_access |
    pointer_deref |
    address_of |
    identifier |
    "(" ~ expr ~ ")"
}

// Builtin function calls (phase 1)
strncmp_call = { "strncmp" ~ "(" ~ expr ~ "," ~ expr ~ "," ~ int ~ ")" }
starts_with_call = { "starts_with" ~ "(" ~ expr ~ "," ~ expr ~ ")" }
memcmp_call = { "memcmp" ~ "(" ~ expr ~ "," ~ expr ~ ("," ~ expr)? ~ ")" }
hex_call = { "hex" ~ "(" ~ string ~ ")" }

special_var = @{ "$" ~ (ASCII_ALPHANUMERIC | "_")+ }

// Complex variable access patterns
complex_variable = { chain_access | array_access | member_access | pointer_deref | address_of }

chain_access = { identifier ~ ("." ~ identifier)* ~ ("[" ~ expr ~ "]")? }
array_access = { identifier ~ "[" ~ expr ~ "]" ~ ("." ~ identifier)* }
// Ensure member_access doesn't preempt cases followed by '[' (those should be parsed by chain_access)
member_access = { identifier ~ ("." ~ identifier)+ ~ !("[") }
pointer_deref = { "*" ~ ( "(" ~ expr ~ ")" | complex_variable | identifier ) }
address_of = { "&" ~ ( "(" ~ expr ~ ")" | complex_variable | identifier ) }

add_op = { "+" | "-" }
mul_op = { "*" | "/" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
// Integer literals
int = @{ ASCII_DIGIT+ }
hex_int = @{ "0x" ~ ASCII_HEX_DIGIT+ }
oct_int = @{ "0o" ~ ASCII_OCT_DIGIT+ }
bin_int = @{ "0b" ~ ("0"|"1")+ }
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" } 
bool = @{ "true" | "false" }
